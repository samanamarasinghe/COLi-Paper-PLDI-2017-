\section{Conclusion and Future Work}

In this paper we introduce \framework, a mid-end compiler for domain specific languages that separates the algorithm, the schedule and the data layout.
\framework has a three-layer intermediate representation that enables the separation.  The first layer of the IR describes computations without describing how these computations are scheduled or where the intermediate values are stored.  The second layer describes how computations are scheduled but does not represent where the values are stored.  The third layer specifies data layout.

\framework{} provides three methods to generate Layer II and Layer III.  The first method is a set of transformation primitives, similar to the primitives used in Halide~\cite{halide_12} or ChiLL~\cite{chill}. The second method is the direct generation of Layer II and Layer III.
The third method is a quasi-affine schedule (map) that transforms the set of computations in Layer I into a set of computations in Layer II.

We evaluate \framework by creating a new middle-end for the Halide compiler, and demonstrate no loss of performance.  Finally, we also demonstrate transformations made possible by \framework that are not possible in Halide such as skewing and fusion, increasing performance by up to $10\times$.

Future work includes support for more DSL compilers and adding a layer of automation on top of the current framework; for example, we want to enable automatic scheduling within \framework.