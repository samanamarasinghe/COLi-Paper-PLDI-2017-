\begin{comment}

\begin{figure*}[t!]
    \centering
    \scriptsize
\begin{tabular}{cl|@{}l}
\multicolumn{3}{c}{\textbf{Constraints:} \boldsymbol{$\ \ \ C_n: 0\leq i < N, \ \ \ \ \ \ C_m: 0\leq j < M, \ \ \ \ C_{m'}: 1\leq j < M, \ \ \ \ C_{k}: 0\leq k < 2$}}
\\\hline
  &
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
    \textbf{Generated Code (different versions)}
  &
    \ \ \ \ \ \ \ \ \ \ \ \ \ \  
    \textbf{\framework representation (Layer I, Layer II and Layer III)}
\\\hline

{\textbf{\normalsize(a)}} &
\begin{lstlisting}[language=C,escapechar=@]
float b1[M], b2[M], out[N][M], avg[N][M]
a = 1.5
for (i in 0..N)
  for (j in 0..M)
    b1[j] = a*f1[i,j]@\label{fig:motivating:code1:stmt1}@
  for (j in 0..M)
    b2[j] = a*f2[i,j]@\label{fig:motivating:code1:stmt2}@
  for (j in 0..M)
    out[i,j] = b1[j] & b2[j]@\label{fig:motivating:code1:stmt3}@
for (i in 0..N)
  for (j in 1..M)
    avg[i,j] = (out[i,j-1] + out[i,j])/2
\end{lstlisting} 
    &  
\begin{tabular}{c|l}
\multirow{5}{*}{\textbf{Layer I}}
    & {\boldsymbol{$\{a(0)\} $}}: $\ 1.5$\\
    & {\boldsymbol{$\{b_1\ (i, j): C_n \wedge C_m\} $}}: $\ a(0)*f_1(i,  j)$  /* $C_n$ and $C_m$ are defined above. */ \\       
    & {\boldsymbol{$\{b_2\ (i, j): C_n \wedge C_m\}$}}: $\ a(0)*f_2(i,  j)$ \\
    & {\boldsymbol{$\{out(i, j): C_n \wedge C_m\}$}}: $\ b_1(i, j) \ \&\ b_2(i, j)$ \\
    & {\boldsymbol{$\{avg(i, j): C_n \wedge C_{m'}\}$}}: $(out(i,j-1) + out(i,j))/2$\\\hline
\multirow{5}{*}{\textbf{Layer II}}
    & $\{\ \ a[0]\} : \ 1.5$  \\
    & $\{\ b_1[1, i, 0, j]: C_n \wedge C_m\}: a[0]*f_1[i, j]$ /* $C_n$ and $C_m$ are defined above. */ \\
    & $\{\ b_2[1, i, 1, j]: C_n \wedge C_m\}: a[0]*f_2[i, j]$ \\
    & $\{out[1, i, 2, j]: C_n \wedge C_m\}: b_1[1,i,0,j] \ \&\ b_2[1,i,1,j]$ \\
    & $\{avg[2, i, j]: C_n \wedge C_{m'}\}: (out[1,i,2,j-1] + out[1,i,2,j])/2$ \\\hline
\multirow{8}{*}{\textbf{Layer III}}
    & Layer II representation + the following data \ mapping\\
    & $\{\ \ a[0] \rightarrow scalar_{0}\}$\\
    & $\{\ b_1[1, i, 0, j] \rightarrow buf_{b1}[j]:  C_n \wedge C_m \}$ /* $C_n$ and $C_m$ are defined above. */ \\
    & $\{\ b_2[1, i, 1, j] \rightarrow buf_{b2}[j]:  C_n \wedge C_m\}$\\
    & $\{out[1, i, 2, j] \rightarrow buf_{out}[i,j]:  C_n \wedge C_m\}$\\
    & $\{avg[2, i, j] \rightarrow buf_{avg}[i,j]:  C_n \wedge C_{m'} \}$\\
\end{tabular}
    \\\hline
{\textbf{\normalsize(b)}} &
\begin{lstlisting}[language=C,escapechar=@]
float b1[N][M], b2[N][M], out[N][M],
      avg[N][M]
a = 1.5
parallel for (i in 0..N)
  for (j in 0..M)
    b1[i, j] = a*f1[i,j]
  for (j in 0..M)
    b2[i, j] = a*f2[i,j]
  for (j in 0..M)
    out[i,j] = b1[j] & b2[j]
for (i in 0..N)
  for (j in 1..M)
    avg[i,j] = (out[i,j-1] + out[i,j])/2
\end{lstlisting}
    & 
\begin{tabular}{c|l}
 \multirow{3}{*}{\textbf{Layer I }}  & \\ & Same as (a) Layer I\\ \\\hline
 \multirow{6}{*}{\textbf{Layer II}}
     & $\{\ \ a[0]\} : \ 1.5$  \\
    & $\{\ b_1[1, i (cpu, virtual), 0, j]: C_n \wedge C_m\}: a[0]*f_1[i, j]$ \\
    & $\{\ b_2[1, i (cpu, virtual), 1, j]: C_n \wedge C_m\}: a[0]*f_2[i, j]$ \\
    & $\{out[1, i (cpu, virtual), 2, j]: C_n \wedge C_m\}: b_1[1,i,0,j] \ \&\ b_2[1,i,1,j]$ \\
    & $\{avg[2, i (cpu, virtual), j]: C_n \wedge C_{m'}\}: (out[1,i,2,j-1] + out[1,i,2,j])/2$ 
 \\\hline
 \multirow{6}{*}{\textbf{Layer III}}
    & Layer II representation + the following data \ mapping\\        
    & $\{\ \ a[0] \rightarrow scalar_{0}\}$\\
    & $\{\ b_1[1, i (cpu, virtual), 0, j] \rightarrow buf_{b1}[i,j]:  C_n \wedge C_m \}$\\
    & $\{\ b_2[1, i (cpu, virtual), 1, j] \rightarrow buf_{b2}[i,j]:  C_n \wedge C_m\}$\\
    & $\{out[1, i (cpu, virtual), 2, j] \rightarrow buf_{out}[i,j]:  C_n \wedge C_m\}$\\
    & $\{avg[2, i (cpu, virtual), j] \rightarrow buf_{avg}[i,j]:  C_n \wedge C_{m'} \}$\\
\end{tabular}  
    \\\hline
{\textbf{\normalsize(c)}} &
\begin{lstlisting}[language=C]
float b1[N][M], b2[N][M], out[N][M],
      avg[N][M]
a = 1.5
parallel for (i in 0..N)
  for (j in 0..M)
    b1[i,j] = a*f1[i,j]
    b2[i,j] = a*f2[i,j]
    out[i,j] = b1[i,j] & b2[i,j]
for (i in 0..N)
  for (j in 1..M)
    avg[i,j] = (out[i,j-1] + out[i,j])/2
\end{lstlisting}
    & 
\begin{tabular}{c|l}
 \multirow{3}{*}{\textbf{Layer I }}  & \\ & Same as (a) Layer I\\ \\\hline
 \multirow{5}{*}{\textbf{Layer II}}
    & $\{\ \ a[0]\} : \ 1.5$\\
    & $\{\ b_1[1, i (cpu, virtual), j, 0]: C_n \wedge C_m\}: a[0]*f_1[i, j]$\\
    & $\{\ b_2[1, i (cpu, virtual), j, 1]: C_n \wedge C_m\}: a[0]*f_2[i, j]$\\
    & $\{out[1, i (cpu, virtual), j, 2]: C_n \wedge C_m\}: b_1[1,i,j,0] \ \&\ b_2[1,i,j,1]$\\
    &$\{avg[2, i (cpu,virtual), j]:C_n\wedge C_{m'}\}:(out[1,i,j-1,2]+out[1,i,j,2])/2$\\\hline
 \multirow{8}{*}{\textbf{Layer III}}
    & Layer II representation + the following data \ mapping\\
    & $\{a\ [0] \rightarrow scalar_{0}\}$\\
    & $\{b_1\ [1, i (cpu, virtual), j, 0] \rightarrow buf_{b1}[i,j]:  C_n \wedge C_m \}$\\
    & $\{b_2\ [1, i (cpu, virtual), j, 1] \rightarrow buf_{b2}[i,j]:  C_n \wedge C_m\}$\\
    & $\{out[1, i (cpu, virtual), j, 2] \rightarrow buf_{out}[i,j]:  C_n \wedge C_m\}$\\
    & $\{avg[2, i (cpu, virtual), j] \rightarrow buf_{avg}[i,j]:  C_n \wedge C_{m'} \}$\\
 \end{tabular}
\\\hline
{\textbf{\normalsize(d)}} & 
\begin{lstlisting}[language=C,escapechar=@]
float out[N][M], avg[N][M]
a = 1.5
parallel for (i in 0..N)
  for (j in 0..M)
    float t1 = a*f1[i,j]
    float t2 = a*f2[i,j]
    out[i,j] = t1 & t2
for (i in 0..N)
  for (j in 1..M)
    avg[i,j] = (out[i,j-1] + out[i,j])/2
\end{lstlisting}
    &    

\begin{tabular}{c|l}
 \multirow{3}{*}{\textbf{Layer I }}  & \\ & Same as (a) Layer I\\ \\\hline
 \multirow{3}{*}{\textbf{Layer II}}  & \\ & Same as (c) Layer II\\ \\\hline
 \multirow{8}{*}{\textbf{Layer III}}
    & Layer II representation + the following data \ mapping\\
    & $\{\ \ \ a[0] \rightarrow scalar_{0}\}$\\
    & $\{\ \ b_1[1, i (cpu, virtual), j, 0] \rightarrow scalar_{1}:  C_n \wedge C_m \}$\\
    & $\{\ \ b_2[1, i (cpu, virtual), j, 1] \rightarrow scalar_{2}:  C_n \wedge C_m\}$\\
    & $\{out[1, i (cpu, virtual), j, 2] \rightarrow buf_{out}[i,j]:  C_n \wedge C_m\}$\\
    & $\{avg[2, i (cpu, virtual), j, 0] \rightarrow buf_{avg}[i,j]:  C_n \wedge C_{m'} \}$\\   
 \end{tabular} 
    \\\hline
{\textbf{\normalsize(e)}} &
\begin{lstlisting}[language=C,escapechar=@]
float b1[N][2], b2[N][2], out[N][2],
      avg[N][M];
a = 1.5
parallel for (i in 0..N)
  for (j in 0..M)
    for (k in 0..2)
      b1[i,k] = a*f1[i,j-1+k]@\label{fig:motivating:code4:stmt1}@
    for (k in 0..2)
      b2[i,k] = a*f2[i,j-1+k]
    for (k in 0..2)
      out[i,k] = b1[i,k] & b2[i,k]@\label{fig:motivating:code4:stmt3}@
    if (j > 0)  
      avg[i,j] = (out[i,0] + out[i,1])/2
\end{lstlisting}
    & 
\begin{tabular}{c|l}
 \multirow{3}{*}{\textbf{Layer I }}  & \\ & Same as (a) Layer I\\ \\\hline
 \multirow{8}{*}{\textbf{Layer II}}
    & $\{\ \ a[0]\}: 1.5$\\
    & $\{b_1\ [1, i (cpu, virtual),  j, 0, k]: C_n \wedge C_m \wedge C_k\}: a[0]*f_1[i, j-1+k]$\\
    & $\{b_2\ [1, i (cpu, virtual),  j, 1, k]: C_n \wedge C_m \wedge C_k\}: a[0]*f_2[i, j-1+k]$\\
    & $\{out[1, i (cpu, virtual), j, 2, k]: C_n \wedge C_m \wedge C_k\}: b_1[1,i,j,0,k] \ \&\ b_2[1,i,j,1,k]$\\
    & $\{avg[1, i (cpu, virtual), j, 3, 0]: C_n \wedge C_{m'}\ \ \ \ \ \ \ \ \ \}: (out[1,i,j,2,0] + out[1,i,j,2,1])/2$ \\
    \hline
 \multirow{8}{*}{\textbf{Layer III}}
    & Layer II representation + the following data \ mapping\\
    & $\{a\ [0] \rightarrow scalar_0\}$\\        %
    & $\{b_1\ [1, i (cpu, virtual), j, 0, k] \rightarrow buf_{b1}[i,k]:  C_n \wedge C_m \wedge C_k\}$ \\
    & $\{b_2\ [1, i (cpu, virtual), j, 1, k] \rightarrow buf_{b2}[i,k]:  C_n \wedge C_m \wedge C_k\}$ \\
    & $\{out[1, i (cpu, virtual), j, 2, k] \rightarrow buf_{out}[i,k]:  C_n \wedge C_m \wedge C_k\}$\\
    & $\{avg[1, i (cpu, virtual), j, 3, 0] \rightarrow buf_{avg}[i,j]:  C_n \wedge C_{m'} \}$\\        %
 \end{tabular} 
    \\
    \end{tabular}
    \caption{Resulting code and the three layers of representation for 
    (a) Unoptimized code implementing the motivating example,
    (b) Full expansion of b1 and b2 to allow parallelism,
    (c) Loop fusion,
    (d) Contraction of b1 and b2 to scalars, and 
    (e) Further fusion with redundant computation. }
    \label{fig:example-ir}
\end{figure*}
\end{comment}

%%%%%%%%%%%%%%%%%%%%%

%\begin{itemize}
%  \item A three-level IR that separates the algorithm from the schedule and the data-layout. Since the memory-layout is not represented in the high levels of the IR where scheduling happens, reasoning about code transformations is easier since it does not involve data-layout transformations as well.
  %, since code transformation passes do not need to transform the data layout.  The third level specifies the data-layout.
  %The first level describes the computations without describing how these computations are scheduled or where they are stored.  The second level describes how computations are scheduled but does not represent how they are stored.  
%  \item The framework allows the user to use an affine transformation or a non-affine transformation to transform the iteration domain to the time-space domain.
%  \item A code generator that takes as input the time-space representation regardless of whether it was generated using an affine or a non-affine transformation; it generates a sequence of loop nests as output.
%  \item An open source framework that implements the three-level IR and generates code targeting single core CPU, multi-core CPU with vectorization and targets GPU architectures.  This framework is validated on the Halide industrial DSL compiler.
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%To illustrate this workflow, let us take the following code that implements a $3\times3$ box filter defined as two $3\times1$ filters.

%\begin{lstlisting}[language=C,basicstyle=\scriptsize]
%for (x in 0..N)
% for (y in 0..M)
%  blurx(x,y) = (in(x-1,y) + in(x,y) + in(x+1,y))/3
%for (x in 0..N)
% for (y in 0..M)
%  blury(x,y) = (blurx(x,y-1) + blurx(x,y)+blurx(x,y+1))/3
%\end{lstlisting}

%The first computation, blurx, computes a horizontal blur of the input by averaging over a $3\times1$ window and the second computation, blury, computes the final blur by averaging a $1\times3$ window of the output from the first computation.

% Let us suppose that we want to perform 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%% Archive for text removed from the paper (if needed later)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\framework uses an expressive representation for the three levels of the IR based on the polyhedral model; The separation between the three-levels is designed not only to separate computations from the schedule and data-layout specifications but also to open the door for affine transformation frameworks to work in synergy with non-affine transformation frameworks.  This is mainly because the transformation from one IR level to another can be done using an affine transformation or a non-affine transformation framework.  Code generation is unified, whether an affine or a non-affine transformation framework is used.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}

\subsection{Integrating Affine and Non-affine Transformations in one Framework}

An extensive amount of research has been done in the area of polyhedral compilation and affine program transformations~\cite{}.  Polyhedral compilation uses an abstract mathematical representation to model programs: the iteration domain of a statement is represented as a set described using affine constraints (linear constraints) while loop transformations are expressed using affine relations between the iteration domain and a time domain.  Although such a representation is very expressive and can express affine transformations such as non-parametric loop tiling, loop fusion, loop distribution, loop skewing, ... little attention has been given to the integration of affine transformation frameworks with non-affine transformation frameworks (which can express non-affine transformations such as parametric tiling, parametric splitting, ...).

In this paper, we introduce a common representation that can be used by both frameworks.  It is hybrid representation that combines the expressiveness of the polyhedral representations with the generality of interval based representations.  Transformations are still done in separate frameworks but the representation of the iteration domain, the time-space domain and the data-domain is unified.  We use one code generator to generate code in both cases.  We believe that such a representation is the right level of abstraction that can opens the door for polyhedral and affine-transformation frameworks to work in synergy with non-affine transformation frameworks.  This allows \framework to perform advanced transformations that are difficult to perform for a non-affine framework yet it can apply many classes of non-affine transformations.

\subsection{Contributions}

\framework is a intermediate representation and an open source framework for advanced iteration space transformations. It supports affine transformations and some classes of non-affine transformations.  The paper introduces:
\begin{itemize}
  \item A three-level IR that separates the algorithm from the schedule and the data-layout.  The first level describes the computations without describing how these computations are scheduled or where they are stored.  The second level describes how computations are scheduled but does not represent how they are stored.  Since this level does not represent the memory-layout, reasoning about code transformations becomes easier, since code transformation passes do not need to transform the data layout.  The third level specifies the data-layout.
  \item A hybrid representation for the iteration domain and the time-space domain; this representation is based on integer intervals and on integer sets described with affine constraints.
  \item A code generator that takes as input the hybrid time-space representation (which is a combination of integer intervals and affine constraints) and generates as output a sequence of loop nests.
  \item The framework allows the application and the composition of affine transformations as well as some classes of non-affine transformations.
  \item An open source framework that implements the three-level IR and generates code targeting single core CPU, multi-core CPU with vectorization and targets GPU architectures.  This level is validated on the Halide DSL industrial compiler.
\end{itemize}



\begin{figure}[h]
\begin{lstlisting}[language=C,basicstyle=\scriptsize]
for (i in 0..N)
  for (j in 0..M)
    y(i,j) = 66*rgb(i,j,0) + 129*rgb(i,j,1) + 25*rgb(i,j,2)
for (i in 0..N)
  for (j in 0..M)
    u(i,j) = -38*rgb(2*i,2*j,0) - 74*rgb(2*i,2*j,1) + 112*rgb(2*i,2*j,2)
for (i in 0..N)
  for (j in 0..M)
    v(i,j) = 112*rgb(2*i,2*j,0) - 94*rgb(2*i,2*j,1) - 18*rgb(2*i,2*j,2)
for (i in 0..N)
  for (j in 0..M)
    consumer(i,j) = y(i,j) + u(i,j) + v(i,j)
\end{lstlisting}
\caption{\label{fig:rgb2yuv1} RGB to YUV}
\end{figure}

\end{comment}

%%%%%